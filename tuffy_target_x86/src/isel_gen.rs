// @generated by tuffy_isel_gen -- DO NOT EDIT

use crate::inst::{CondCode, MInst, OpSize};
use crate::reg::Gpr;
use tuffy_ir::instruction::{ICmpOp, Op};
use tuffy_ir::types::Annotation;
use tuffy_ir::value::ValueRef;
use tuffy_regalloc::VReg;

fn gen_add(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::AddRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_sub(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::SubRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_mul(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::ImulRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_or(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::OrRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_and(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::AndRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_xor(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::XorRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_shl(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    let v1 = ctx.alloc.alloc_fixed(Gpr::Rcx.to_preg());
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v1,
        src: rhs,
    });
    ctx.out.push(MInst::ShlRCL {
        size: OpSize::S64,
        dst: v0,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_shr_signed(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    let v1 = ctx.alloc.alloc_fixed(Gpr::Rcx.to_preg());
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v1,
        src: rhs,
    });
    ctx.out.push(MInst::SarRCL {
        size: OpSize::S64,
        dst: v0,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_shr_unsigned(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    let v1 = ctx.alloc.alloc_fixed(Gpr::Rcx.to_preg());
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v1,
        src: rhs,
    });
    ctx.out.push(MInst::ShrRCL {
        size: OpSize::S64,
        dst: v0,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_min_signed(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.out.push(MInst::CmpRR {
        size: OpSize::S64,
        src1: lhs,
        src2: rhs,
    });
    ctx.out.push(MInst::CMOVcc {
        size: OpSize::S64,
        cc: CondCode::L,
        dst: v0,
        src: lhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_min_unsigned(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.out.push(MInst::CmpRR {
        size: OpSize::S64,
        src1: lhs,
        src2: rhs,
    });
    ctx.out.push(MInst::CMOVcc {
        size: OpSize::S64,
        cc: CondCode::B,
        dst: v0,
        src: lhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_max_signed(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.out.push(MInst::CmpRR {
        size: OpSize::S64,
        src1: lhs,
        src2: rhs,
    });
    ctx.out.push(MInst::CMOVcc {
        size: OpSize::S64,
        cc: CondCode::G,
        dst: v0,
        src: lhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_max_unsigned(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.out.push(MInst::CmpRR {
        size: OpSize::S64,
        src1: lhs,
        src2: rhs,
    });
    ctx.out.push(MInst::CMOVcc {
        size: OpSize::S64,
        cc: CondCode::A,
        dst: v0,
        src: lhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_count_ones(ctx: &mut super::IselCtx, vref: ValueRef, src: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::Popcnt { dst: v0, src });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_count_leading_zeros(ctx: &mut super::IselCtx, vref: ValueRef, src: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::Lzcnt { dst: v0, src });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_count_trailing_zeros(ctx: &mut super::IselCtx, vref: ValueRef, src: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::Tzcnt { dst: v0, src });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_icmp(
    ctx: &mut super::IselCtx,
    vref: ValueRef,
    lhs: VReg,
    rhs: VReg,
    cmp_op: ICmpOp,
    lhs_ann: Option<Annotation>,
) -> Option<()> {
    ctx.out.push(MInst::CmpRR {
        size: OpSize::S64,
        src1: lhs,
        src2: rhs,
    });
    let cc = super::icmp_to_cc(cmp_op, lhs_ann);
    ctx.cmps.set(vref, cc);
    Some(())
}

fn gen_ptr_add(ctx: &mut super::IselCtx, vref: ValueRef, ptr: VReg, offset: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: ptr,
    });
    ctx.out.push(MInst::AddRR {
        size: OpSize::S64,
        dst: v0,
        src: offset,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

fn gen_ptr_diff(ctx: &mut super::IselCtx, vref: ValueRef, lhs: VReg, rhs: VReg) -> Option<()> {
    let v0 = ctx.alloc.alloc();
    ctx.out.push(MInst::MovRR {
        size: OpSize::S64,
        dst: v0,
        src: lhs,
    });
    ctx.out.push(MInst::SubRR {
        size: OpSize::S64,
        dst: v0,
        src: rhs,
    });
    ctx.regs.assign(vref, v0);
    Some(())
}

#[allow(unused_variables)]
pub(super) fn try_select_generated(
    ctx: &mut super::IselCtx,
    vref: ValueRef,
    op: &Op,
) -> Option<()> {
    match op {
        Op::Add(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_add(ctx, vref, l, r)
        }
        Op::Sub(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_sub(ctx, vref, l, r)
        }
        Op::Mul(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_mul(ctx, vref, l, r)
        }
        Op::Or(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_or(ctx, vref, l, r)
        }
        Op::And(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_and(ctx, vref, l, r)
        }
        Op::Xor(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_xor(ctx, vref, l, r)
        }
        Op::Shl(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_shl(ctx, vref, l, r)
        }
        Op::Shr(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            match lhs.annotation {
                Some(Annotation::Signed(_)) => gen_shr_signed(ctx, vref, l, r),
                Some(Annotation::Unsigned(_)) => gen_shr_unsigned(ctx, vref, l, r),
                _ => gen_shr_unsigned(ctx, vref, l, r),
            }
        }
        Op::Min(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            match lhs.annotation {
                Some(Annotation::Signed(_)) => gen_min_signed(ctx, vref, l, r),
                Some(Annotation::Unsigned(_)) => gen_min_unsigned(ctx, vref, l, r),
                _ => gen_min_unsigned(ctx, vref, l, r),
            }
        }
        Op::Max(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            match lhs.annotation {
                Some(Annotation::Signed(_)) => gen_max_signed(ctx, vref, l, r),
                Some(Annotation::Unsigned(_)) => gen_max_unsigned(ctx, vref, l, r),
                _ => gen_max_unsigned(ctx, vref, l, r),
            }
        }
        Op::CountOnes(val) => {
            let s = ctx.ensure_in_reg(val.value)?;
            gen_count_ones(ctx, vref, s)
        }
        Op::CountLeadingZeros(val) => {
            let s = ctx.ensure_in_reg(val.value)?;
            gen_count_leading_zeros(ctx, vref, s)
        }
        Op::CountTrailingZeros(val) => {
            let s = ctx.ensure_in_reg(val.value)?;
            gen_count_trailing_zeros(ctx, vref, s)
        }
        Op::PtrAdd(ptr, offset) => {
            let p = ctx.ensure_in_reg(ptr.value)?;
            let o = ctx.ensure_in_reg(offset.value)?;
            gen_ptr_add(ctx, vref, p, o)
        }
        Op::PtrDiff(lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_ptr_diff(ctx, vref, l, r)
        }
        Op::ICmp(cmp_op, lhs, rhs) => {
            let l = ctx.ensure_in_reg(lhs.value)?;
            let r = ctx.ensure_in_reg(rhs.value)?;
            gen_icmp(ctx, vref, l, r, *cmp_op, lhs.annotation)
        }
        _ => None,
    }
}
