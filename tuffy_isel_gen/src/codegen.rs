//! Generate Rust isel dispatch code from parsed JSON rules.

use std::collections::HashMap;
use std::fmt::Write;

use crate::schema::*;

/// Generate the complete `isel_gen.rs` source file.
pub fn generate(rules: &[IselRule]) -> String {
    let mut out = String::new();
    writeln!(out, "// @generated by tuffy_isel_gen -- DO NOT EDIT").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "use crate::inst::{{CondCode, MInst, OpSize}};").unwrap();
    writeln!(out, "use crate::reg::Gpr;").unwrap();
    writeln!(out, "use tuffy_ir::instruction::{{ICmpOp, Op}};").unwrap();
    writeln!(out, "use tuffy_ir::types::Annotation;").unwrap();
    writeln!(out, "use tuffy_ir::value::ValueRef;").unwrap();
    writeln!(out, "use tuffy_regalloc::VReg;").unwrap();
    writeln!(out).unwrap();

    // Generate per-rule helper functions.
    for rule in rules {
        generate_rule_fn(&mut out, rule);
    }

    // Generate the dispatch function.
    generate_dispatch(&mut out, rules);

    out
}

/// Map from register name to Rust variable name, tracking fresh allocations.
struct RegEnv {
    map: HashMap<String, String>,
    counter: u32,
}

impl RegEnv {
    fn new() -> Self {
        Self {
            map: HashMap::new(),
            counter: 0,
        }
    }

    fn resolve(&mut self, r: &RegRef, out: &mut String) -> String {
        match r.kind {
            RegRefKind::Named => {
                // Named refs are function parameters — use the name directly.
                r.name.clone()
            }
            RegRefKind::Fresh => {
                if let Some(existing) = self.map.get(&r.name) {
                    return existing.clone();
                }
                let var = format!("v{}", self.counter);
                self.counter += 1;
                writeln!(out, "    let {var} = ctx.alloc.alloc();").unwrap();
                self.map.insert(r.name.clone(), var.clone());
                var
            }
            RegRefKind::FreshFixed => {
                if let Some(existing) = self.map.get(&r.name) {
                    return existing.clone();
                }
                let preg = fixed_reg_to_rust(r.reg.as_deref().unwrap_or("rcx"));
                let var = format!("v{}", self.counter);
                self.counter += 1;
                writeln!(out, "    let {var} = ctx.alloc.alloc_fixed({preg});").unwrap();
                self.map.insert(r.name.clone(), var.clone());
                var
            }
        }
    }
}

fn fixed_reg_to_rust(reg: &str) -> &'static str {
    match reg {
        "rax" => "Gpr::Rax.to_preg()",
        "rcx" => "Gpr::Rcx.to_preg()",
        "rdx" => "Gpr::Rdx.to_preg()",
        "rbp" => "Gpr::Rbp.to_preg()",
        _ => panic!("unknown fixed register: {reg}"),
    }
}

fn size_to_rust(s: &str) -> &'static str {
    match s {
        "s8" => "OpSize::S8",
        "s16" => "OpSize::S16",
        "s32" => "OpSize::S32",
        "s64" => "OpSize::S64",
        _ => panic!("unknown size: {s}"),
    }
}

fn cc_to_rust(cc: &str) -> &'static str {
    match cc {
        "e" => "CondCode::E",
        "ne" => "CondCode::Ne",
        "l" => "CondCode::L",
        "le" => "CondCode::Le",
        "g" => "CondCode::G",
        "ge" => "CondCode::Ge",
        "b" => "CondCode::B",
        "be" => "CondCode::Be",
        "a" => "CondCode::A",
        "ae" => "CondCode::Ae",
        _ => panic!("unknown condition code: {cc}"),
    }
}

/// Collect the named register parameters from a pattern.
fn pattern_params(pattern: &IrPattern) -> Vec<String> {
    match pattern {
        IrPattern::Binop { lhs, rhs, .. } => vec![lhs.reg.clone(), rhs.reg.clone()],
        IrPattern::Unop { val, .. } => vec![val.reg.clone()],
        IrPattern::Icmp { lhs, rhs } => vec![lhs.reg.clone(), rhs.reg.clone()],
    }
}

/// Generate a per-rule function like `fn gen_add(...)`.
fn generate_rule_fn(out: &mut String, rule: &IselRule) {
    let params = pattern_params(&rule.pattern);
    let param_list: String = params
        .iter()
        .map(|p| format!("{p}: VReg"))
        .collect::<Vec<_>>()
        .join(", ");

    let extra_params = if rule.icmp_cc_from_op {
        ", cmp_op: ICmpOp, lhs_ann: Option<Annotation>"
    } else {
        ""
    };

    writeln!(
        out,
        "fn gen_{name}(ctx: &mut super::IselCtx, vref: ValueRef, {param_list}{extra_params}) -> Option<()> {{",
        name = rule.name
    )
    .unwrap();

    // Build register environment with named params pre-populated.
    let mut env = RegEnv::new();
    for p in &params {
        env.map.insert(p.clone(), p.clone());
    }

    // Emit instructions.
    let mut inst_lines = String::new();
    for inst in &rule.emit {
        emit_inst(&mut inst_lines, inst, &mut env);
    }
    out.push_str(&inst_lines);

    // Assign result.
    match &rule.result {
        ResultKind::Reg { name } => {
            let var = env.map.get(name).expect("result reg not found in env");
            writeln!(out, "    ctx.regs.assign(vref, {var});").unwrap();
        }
        ResultKind::CmpFlags => {
            writeln!(out, "    let cc = super::icmp_to_cc(cmp_op, lhs_ann);").unwrap();
            writeln!(out, "    ctx.cmps.set(vref, cc);").unwrap();
        }
        ResultKind::None => {}
    }

    writeln!(out, "    Some(())").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();
}

/// Format a struct field assignment, using shorthand when variable name matches field name.
fn field(name: &str, var: &str) -> String {
    if name == var {
        name.to_string()
    } else {
        format!("{name}: {var}")
    }
}

/// Emit a single MInst push statement.
fn emit_inst(out: &mut String, inst: &EmitInst, env: &mut RegEnv) {
    // We need a separate buffer for alloc lines that must come before the push.
    let mut alloc_buf = String::new();

    let push_line = match inst {
        EmitInst::MovRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::MovRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::AddRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::AddRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::SubRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::SubRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::ImulRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::ImulRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::OrRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::OrRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::AndRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::AndRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::XorRR { size, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::XorRR {{ size: {sz}, dst: {d}, src: {s} }});")
        }
        EmitInst::ShlRCL { size, dst } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::ShlRCL {{ size: {sz}, dst: {d} }});")
        }
        EmitInst::ShrRCL { size, dst } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::ShrRCL {{ size: {sz}, dst: {d} }});")
        }
        EmitInst::SarRCL { size, dst } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::SarRCL {{ size: {sz}, dst: {d} }});")
        }
        EmitInst::CmpRR { size, src1, src2 } => {
            let s1 = env.resolve(src1, &mut alloc_buf);
            let s2 = env.resolve(src2, &mut alloc_buf);
            let sz = size_to_rust(size);
            format!("    ctx.out.push(MInst::CmpRR {{ size: {sz}, src1: {s1}, src2: {s2} }});")
        }
        EmitInst::CMOVcc { size, cc, dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let sz = size_to_rust(size);
            let c = cc_to_rust(cc);
            format!(
                "    ctx.out.push(MInst::CMOVcc {{ size: {sz}, cc: {c}, dst: {d}, src: {s} }});"
            )
        }
        EmitInst::Popcnt { dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let fd = field("dst", &d);
            let fs = field("src", &s);
            format!("    ctx.out.push(MInst::Popcnt {{ {fd}, {fs} }});")
        }
        EmitInst::Lzcnt { dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let fd = field("dst", &d);
            let fs = field("src", &s);
            format!("    ctx.out.push(MInst::Lzcnt {{ {fd}, {fs} }});")
        }
        EmitInst::Tzcnt { dst, src } => {
            let d = env.resolve(dst, &mut alloc_buf);
            let s = env.resolve(src, &mut alloc_buf);
            let fd = field("dst", &d);
            let fs = field("src", &s);
            format!("    ctx.out.push(MInst::Tzcnt {{ {fd}, {fs} }});")
        }
    };

    out.push_str(&alloc_buf);
    writeln!(out, "{push_line}").unwrap();
}

/// Group rules by their IR op name for dispatch.
struct OpGroup {
    op_name: String,
    /// Rules for this op, with their annotation guards on the LHS operand.
    rules: Vec<(AnnGuard, String)>, // (guard, rule_name)
}

/// Generate the `try_select_generated` dispatch function.
fn generate_dispatch(out: &mut String, rules: &[IselRule]) {
    writeln!(out, "#[allow(unused_variables)]").unwrap();
    writeln!(out, "pub(super) fn try_select_generated(").unwrap();
    writeln!(out, "    ctx: &mut super::IselCtx,").unwrap();
    writeln!(out, "    vref: ValueRef,").unwrap();
    writeln!(out, "    op: &Op,").unwrap();
    writeln!(out, ") -> Option<()> {{").unwrap();
    writeln!(out, "    match op {{").unwrap();

    // Group rules by Op variant.
    let mut groups: Vec<OpGroup> = Vec::new();
    let mut icmp_rule: Option<&IselRule> = None;

    for rule in rules {
        match &rule.pattern {
            IrPattern::Binop { op, lhs, .. } => {
                let guard = lhs.ann;
                if let Some(group) = groups.iter_mut().find(|g| g.op_name == *op) {
                    group.rules.push((guard, rule.name.clone()));
                } else {
                    groups.push(OpGroup {
                        op_name: op.clone(),
                        rules: vec![(guard, rule.name.clone())],
                    });
                }
            }
            IrPattern::Unop { op, .. } => {
                groups.push(OpGroup {
                    op_name: op.clone(),
                    rules: vec![(AnnGuard::Any, rule.name.clone())],
                });
            }
            IrPattern::Icmp { .. } => {
                icmp_rule = Some(rule);
            }
        }
    }

    // Emit match arms for each Op variant.
    for group in &groups {
        let op_name = &group.op_name;
        let op_variant = op_variant_pattern(op_name);
        writeln!(out, "        {op_variant} => {{").unwrap();

        // Emit ensure_in_reg for operands.
        let operand_names = op_operand_names(op_name);
        for (var, field) in &operand_names {
            writeln!(
                out,
                "            let {var} = ctx.ensure_in_reg({field}.value)?;"
            )
            .unwrap();
        }

        if group.rules.len() == 1 && group.rules[0].0 == AnnGuard::Any {
            // Single rule, no annotation dispatch needed.
            let rule_name = &group.rules[0].1;
            let args = operand_names
                .iter()
                .map(|(v, _)| v.as_str())
                .collect::<Vec<_>>()
                .join(", ");
            writeln!(out, "            gen_{rule_name}(ctx, vref, {args})").unwrap();
        } else {
            // Multiple rules with annotation guards — dispatch on lhs annotation.
            let first_field = &operand_names[0].1;
            writeln!(out, "            match {first_field}.annotation {{").unwrap();

            let mut has_signed = false;
            let mut has_unsigned = false;
            let mut has_any = false;

            for (guard, rule_name) in &group.rules {
                let args = operand_names
                    .iter()
                    .map(|(v, _)| v.as_str())
                    .collect::<Vec<_>>()
                    .join(", ");
                match guard {
                    AnnGuard::Signed => {
                        has_signed = true;
                        writeln!(
                            out,
                            "                Some(Annotation::Signed(_)) => gen_{rule_name}(ctx, vref, {args}),"
                        )
                        .unwrap();
                    }
                    AnnGuard::Unsigned => {
                        has_unsigned = true;
                        writeln!(
                            out,
                            "                Some(Annotation::Unsigned(_)) => gen_{rule_name}(ctx, vref, {args}),"
                        )
                        .unwrap();
                    }
                    AnnGuard::Any => {
                        has_any = true;
                        writeln!(
                            out,
                            "                _ => gen_{rule_name}(ctx, vref, {args}),"
                        )
                        .unwrap();
                    }
                }
            }

            // If we have signed+unsigned but no "any" fallback, add a default
            // that falls through to the unsigned variant.
            if !has_any && has_signed && has_unsigned {
                // The unsigned rule is the default for unannoted values.
                // Already covered by the unsigned arm matching `_`.
                // Actually we need to change the unsigned arm to be `_ =>`.
                // Let me handle this differently — the unsigned arm should be the default.
            }
            if !has_any {
                // Find the unsigned rule as default, or the first rule.
                let default_rule = group
                    .rules
                    .iter()
                    .find(|(g, _)| *g == AnnGuard::Unsigned)
                    .or_else(|| group.rules.first())
                    .map(|(_, n)| n.as_str())
                    .unwrap();
                let args = operand_names
                    .iter()
                    .map(|(v, _)| v.as_str())
                    .collect::<Vec<_>>()
                    .join(", ");
                writeln!(
                    out,
                    "                _ => gen_{default_rule}(ctx, vref, {args}),"
                )
                .unwrap();
            }

            writeln!(out, "            }}").unwrap();
        }

        writeln!(out, "        }}").unwrap();
    }

    // ICmp arm.
    if let Some(rule) = icmp_rule {
        writeln!(out, "        Op::ICmp(cmp_op, lhs, rhs) => {{").unwrap();
        writeln!(out, "            let l = ctx.ensure_in_reg(lhs.value)?;").unwrap();
        writeln!(out, "            let r = ctx.ensure_in_reg(rhs.value)?;").unwrap();
        writeln!(
            out,
            "            gen_{name}(ctx, vref, l, r, *cmp_op, lhs.annotation)",
            name = rule.name
        )
        .unwrap();
        writeln!(out, "        }}").unwrap();
    }

    writeln!(out, "        _ => None,").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
}

/// Map an IR op name to its `Op::Xxx(lhs, rhs)` match pattern.
fn op_variant_pattern(op_name: &str) -> &'static str {
    match op_name {
        "Add" => "Op::Add(lhs, rhs)",
        "Sub" => "Op::Sub(lhs, rhs)",
        "Mul" => "Op::Mul(lhs, rhs)",
        "Or" => "Op::Or(lhs, rhs)",
        "And" => "Op::And(lhs, rhs)",
        "Xor" => "Op::Xor(lhs, rhs)",
        "Shl" => "Op::Shl(lhs, rhs)",
        "Shr" => "Op::Shr(lhs, rhs)",
        "Min" => "Op::Min(lhs, rhs)",
        "Max" => "Op::Max(lhs, rhs)",
        "CountOnes" => "Op::CountOnes(val)",
        "CountLeadingZeros" => "Op::CountLeadingZeros(val, _)",
        "CountTrailingZeros" => "Op::CountTrailingZeros(val)",
        "PtrAdd" => "Op::PtrAdd(ptr, offset)",
        "PtrDiff" => "Op::PtrDiff(lhs, rhs)",
        _ => panic!("unknown op: {op_name}"),
    }
}

/// Map an IR op name to its operand variable names and field accessors.
fn op_operand_names(op_name: &str) -> Vec<(String, String)> {
    match op_name {
        "Add" | "Sub" | "Mul" | "Or" | "And" | "Xor" | "Shl" | "Shr" | "Min" | "Max"
        | "PtrDiff" => {
            vec![
                ("l".to_string(), "lhs".to_string()),
                ("r".to_string(), "rhs".to_string()),
            ]
        }
        "CountOnes" | "CountLeadingZeros" | "CountTrailingZeros" => {
            vec![("s".to_string(), "val".to_string())]
        }
        "PtrAdd" => vec![
            ("p".to_string(), "ptr".to_string()),
            ("o".to_string(), "offset".to_string()),
        ],
        _ => panic!("unknown op: {op_name}"),
    }
}
